---
layout: default-blank
submitformlinkdirections: "Clicking Run below will check your work and, if it passes, make a page appear above that you can use to submit your work or with further instructions."
---

<!-- publickey in global yaml or layout; canvascourseid in global or exercise page; formlink in global or layout -->

<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<link rel="stylesheet" href="{{site.baseurl}}/assets/css/jstree/style.min.css" />

<style>
    body {
        display: flex;
        flex-direction: column;
        height: 100vh;
        margin: 0;
        font-family: Arial, sans-serif;
    }

    header {
        display: flex;
        justify-content: space-between;
        padding: 10px;
        background: #f4f4f4;
        border-bottom: 1px solid #ccc;
    }

    .left-header {
        display: flex;
        align-items: center;
    }

    .tabs {
        display: flex;
        margin-left: 20px;
    }

    .tab {
        display: flex;
        align-items: center;
        padding: 10px;
        margin-right: 5px;
        background: #ddd;
        border: 1px solid #ccc;
        cursor: pointer;
    }

    .tab.active {
        background: #fff;
        border-bottom: none;
    }

    .tab .close {
        margin-left: 10px;
        color: red;
        cursor: pointer;
    }

    .actions {
        display: flex;
        align-items: center;
    }

    .actions button {
        margin-left: 5px;
        padding: 10px;
    }

    main {
        display: flex;
        flex-grow: 1;
        height: 85vh;
    }

    .left-container, .right-container {
        display: flex;
        flex-direction: column;
        width: 50%;
        flex: none;
        flex-wrap: nowrap;
        flex-shrink: 0;
        flex-grow: 0;         
    }    

    .editor-container {
        border-right: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        height: 75%; 
        flex: none; 
    }
    
    #console {
        width: 100%; 
        box-sizing: border-box; 
        white-space: pre-wrap; 
        overflow-x: hidden;
        overflow-y: auto;
        height: 100%; 
        max-width: 100%;
        flex-shrink: 0;
        flex-grow: 0; 
        flex: none;
        flex-wrap: nowrap;
    }    

    .output-container {
        border-bottom: 1px solid #ccc;
        overflow-y: hidden;
        overflow-x: hidden;
        display: flex;
        flex-direction: column;
        height: 25%; 
        flex: none;
        width: 100%;
        max-width: 100%;
        flex-wrap: nowrap;
        flex-shrink: 0;
        flex-grow: 0;         
    }

    .canvas-container {
        height: 75%; 
        flex: none; 
    }

    .filesystem-container {
        border-right: 1px solid #ccc;
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        height: 25%;
        flex: none; 
    }

    textarea, pre, canvas, audio {
        width: 100%;
        height: 100%;
        box-sizing: border-box;
    }

    #filesystem {
        height: 100%;
        overflow-y: auto;
        background: #f9f9f9;
        border: 1px solid #ccc;
        width: 100%;
    }

    body .ace_scrollbar-v {
        overflow-y: auto;
    }

    body .ace_scrollbar-h {
        overflow-x: auto;
    }

    pre {
        white-space: pre; 
        overflow-x: auto; 
        overflow-y: auto; 
        max-height: 100%; 
        margin: 0; 
    }
    
    .wrap-text-container {
        display: flex;
        align-items: center;
        margin-bottom: 10px; /* Add some space below the checkbox */
    }

    .wrap-text-container label {
        margin-right: 5px; /* Space between label and checkbox */
    }    
</style>

<script src="{{site.baseurl}}/assets/js/jsencrypt.min.js"></script>
<script src="{{site.baseurl}}/assets/js/jszip.min.js"></script>
<script src="{{site.baseurl}}/assets/js/jquery.min.js"></script>
<script src="{{site.baseurl}}/assets/js/jstree.min.js"></script>
<script type="text/javascript" src="{{site.baseurl}}/assets/js/processing.min.js"></script>
<script src="{{site.baseurl}}/assets/js/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="{{site.baseurl}}/assets/js/mathjax/tex-mml-chtml.js"></script>
<script src="{{site.baseurl}}/assets/js/skel.min.js"></script>
<script src="{{site.baseurl}}/assets/js/util.js"></script>
<script src="{{site.baseurl}}/assets/js/main.js"></script>
<script src="{{site.baseurl}}/assets/js/ace.js" type="text/javascript" charset="utf-8"></script>
{% if page.language == "cpp" %}
<script src = "{{site.baseurl}}/assets/js/cpp/process-manager.js"></script>
<script src = "{{site.baseurl}}/assets/js/cpp/runtime.js"></script>
<script src = "{{site.baseurl}}/assets/js/cpp/wasm-tools.js"></script>
{% endif %}
{% if page.language == "sql" %}
<script src="{{site.baseurl}}/assets/js/sql.js/sql.js"></script>
{% endif %}
{% if page.language == "python" %}
<script type="text/javascript" src="{{site.baseurl}}/assets/js/brython.min.js"></script>
<script type="text/javascript" src="{{site.baseurl}}/assets/js/brython_stdlib.min.js"></script>
{% endif %}
{% if page.language == "pyodide" %}
<script type="text/javascript" src="https://cdn.jsdelivr.net/pyodide/v0.26.2/full/pyodide.js"></script>
<script src="{{site.baseurl}}/assets/js/wav.js"></script>
{% endif %}
{% if page.language == "graphics_view" or page.language == "graphics_shader" %}
<script type="text/javascript" src = "{{site.baseurl}}/assets/js/ggslac/jslibs/gl-matrix-min.js"></script>
<script type="text/javascript" src = "{{site.baseurl}}/assets/js/ggslac/jslibs/dat.gui.min.js"></script>
<script type="text/javascript" src = "{{site.baseurl}}/assets/js/ggslac/jslibs/webgl-utils.js"></script>
<script type="text/javascript" src = "{{site.baseurl}}/assets/js/ggslac/jslibs/webgl-debug.js"></script>

<script src="{{site.baseurl}}/assets/js/ggslac/geometry/polymesh.js"></script>
<script src="{{site.baseurl}}/assets/js/ggslac/geometry/basicmesh.js"></script>
<script src="{{site.baseurl}}/assets/js/ggslac/geometry/primitives3d.js"></script>
<script src="{{site.baseurl}}/assets/js/ggslac/geometry/cameras3d.js"></script>
<script src="{{site.baseurl}}/assets/js/ggslac/shaders/shaders.js"></script>
<script src="{{site.baseurl}}/assets/js/ggslac/utils/simpledraw.js"></script>

<script src="{{site.baseurl}}/assets/js/ggslac/viewers/basecanvas.js"></script>
<script src="{{site.baseurl}}/assets/js/ggslac/viewers/scenecanvas.js"></script>
<script src="{{site.baseurl}}/assets/js/ggslac/viewers/matrixanim.js"></script>
{% endif %}

<div id="main" role="main">
  <div class="archive"> 
    <h1 class="page__title">{{ page.title }}{% if page.info.points %} ({{page.info.points}} Points){% endif %}</h1>
            Developed by <a href="https://www.ursinus.edu/live/profiles/4502-christopher-tralie">Professor Tralie</a> and <a href="https://www.ursinus.edu/live/profiles/5313-william-mongan">Professor Mongan</a>.

            {% if page.info.prev or page.info.next %}
            <p>
            {% if page.info.prev %}
            <button onclick="window.location.href = '{{ page.info.prev }} ';"> &lt--- Previous</button>
            {% endif %}
            {% if page.info.next %}
            <button onclick="window.location.href = '{{ page.info.next }}';">Next ---&gt</button>
            {% endif %}
            </p>
            <HR>
            {% endif %}
            
            {% if page.info.goals %}
            <h1>Exercise Goals</h1>
            The goals of this exercise are:
            <ol>
            {% for goal in page.info.goals %}
            <li>{{goal}}</li>
            {% endfor %}
            </ol>
            {% endif %}
            
            {% if page.info.instructions %}
            {{ page.info.instructions }}
            {% endif %}  
            
            <header>
                <div class="left-header">
                    <div class="tabs"></div>
                </div>
                <div class="actions">
                    <span id="user-status"></span>
                    <button id="login">Log In</button>
                    <button id="logout" style="display: none;">Log Out</button>
                    <button id="run" disabled>Save Open Files and Run</button>
                    <button id="save" disabled>Save Open Files</button>
                    <button id="upload" disabled>Upload</button>
                    <button id="new" disabled>New</button>
                    <button id="new-dir" disabled>Make Directory</button>
                    <button id="download" disabled>Download</button>
                    <button id="reset" disabled>Reset</button>
                </div>
            </header>
            <main>
                <div class="left-container">
                    <div class="editor-container" id="editor-container">Welcome to our online modules system!
Be sure to log in with your Urinus ID
before you proceed.  
For example, Professor Tralie's ID is ctralie.

If you are not an Ursinus student, that's fine!
Just make something up, and you can still run everything</div>
                    <div class="wrap-text-container">
                        <label for="wrap-text">Wrap Text</label>
                        <input type="checkbox" id="wrap-text" checked>
                    </div>
                    <button id="clear-console">Clear Console</button>
                    <div class="output-container" id="output-container"> 
                        <pre id="console" style="white-space: pre-wrap; overflow-x: hidden;"></pre>
                    </div>
                </div>
                <div class="right-container">
                    <div class="filesystem-container">
                        <div id="filesystem"></div>
                    </div>
                    <div class="canvas-container">
                        <div id="imageArea"></div>
                        <div id="audioArea"></div>
                        <div id="graphicsArea" style="display:none;">
                            <button id="updateScene">Update Scene</button>
                            {% if page.language == "graphics_shader" %}
                            <button id="updateShaders">Update Shaders</button>
                            {% endif %}
                            <canvas id="GLCanvas1" style="border: none" width="800" height="600"></canvas>
                        </div>

                    </div>
                </div>
            </main>

            {% if page.language == "pyodide" %}
            <div id="pyodideBoilerplate" style="display:none;">
import io, base64
img_str = ""
def save_figure_js():
    global img_str
    buf = io.BytesIO()
    plt.savefig(buf, format='png')
    buf.seek(0)
    img_str = "data:image/png;base64,{}".format(base64.b64encode(buf.read()).decode('UTF-8'))
audio_sav_arr = []
audio_sav_sr = 44100
def save_audio_js(arr, sr):
    global audio_sav_arr
    global audio_sav_sr
    audio_sav_arr = np.array(arr).tolist()
    audio_sav_sr = sr

PYODIDE_COUT = ""
def pyodide_print(s):
    global PYODIDE_COUT
    PYODIDE_COUT += s
    
            </div>
            {% endif %}

            <script type="text/python">
                from browser import document as doc, window
                import tb as traceback
                import sys

                def get_formatted(*args, **kwargs):
                    """
                    My imitation of Python 3's print() function, so I can
                    return the result as a string
                    """
                    sep = ' '
                    end = '\n'
                    if 'sep' in kwargs:
                        sep = kwargs['sep']
                    if 'end' in kwargs:
                        end = kwargs['end']
                    ret = ''
                    for i, arg in enumerate(args):
                        ret += "%s"%arg
                        if i < len(args) - 1:
                            ret += sep
                    return ret + end

                def run_python_code(code):
                    result = ""
                    try:
                        window['python_code_result'] = ''
                        code = code.replace("print(", "window['python_code_result'] += get_formatted(")
                        exec(code)
                        result = window['python_code_result']
                    except Exception as exc:
                        # Formatting exception
                        result = traceback.format_exc()
                    return result
                
                window.run_python_code = run_python_code
            </script>
            <script>
                {% if page.language == "pyodide" %}
                var imgStr = "";
                var audioStr = "";
                {% endif %}
                {% if page.language == "javascript" or page.language == "graphics_view" or page.language == "graphics_shader" %}
                var canvasStr = "";
                {% endif %}

                document.addEventListener('DOMContentLoaded', () => {
                    {% if page.language == "python" %}
                        console.log('Page loaded.  Initializing brython.');
                        brython(1);
                    {% endif %}        
                    const userStatus = document.getElementById('user-status');
                    const loginBtn = document.getElementById('login');
                    const logoutBtn = document.getElementById('logout');
                    const runBtn = document.getElementById('run');
                    const saveBtn = document.getElementById('save');
                    const consoleOutput = document.getElementById('console');
                    const outputContainer = document.getElementById('output-container');
                    const clearButton = document.getElementById('clear-console');
                    const filesystem = document.getElementById('filesystem');
                    const uploadBtn = document.getElementById('upload');
                    const downloadBtn = document.getElementById('download');
                    const newBtn = document.getElementById('new');
                    const newDirBtn = document.getElementById('new-dir');
                    const resetBtn = document.getElementById('reset');
                    const tabs = document.querySelector('.tabs');
                    const imageArea = document.getElementById('imageArea');
                    const audioArea = document.getElementById('audioArea');
                    const canvas = document.getElementById('GLCanvas1');
                    const wrapTextCheckbox = document.getElementById('wrap-text');
                    let ace_editor = null; // set on window load
                    
                    const courseid = '{% if page.canvascourseid %}{{ page.canvascourseid }}{% else %}{{ site.canvascourseid }}{% endif %}';
                    const asmtid = '{{ page.canvasasmtid }}';
                    const defaultuser = 'user';
                    let user = localStorage.getItem('userId') || `${defaultuser}`;
                    const projectName = `{{page.canvasasmtid}}`; 
                    let rootBasePath = `/${user}/${projectName}`;
                    let openFiles = {};
                    const publicKey = `{% if layout.publickey %}{{ layout.publickey }}{% else %}{{ site.publickey }}{% endif %}`;
                    let numAttempts = 0;
                    let correctlyAnswered = false;
                    let feedbackString = "";

                    const initialFiles = [
                        {% for file in page.files %}
                        { fileName: '{{ file.filename }}', content: {{ file.code | strip | jsonify }}, readOnly: {% if file.isreadonly == true or file.isvisible == false %}true{% else %}false{% endif %}, excludeFromExport: {% if file.excludeFromExport == true or file.isvisible == false %}true{% else %}false{% endif %}, ismain: {% if file.ismain %}true{% else %}false{% endif %} },
                        {% endfor %}            
                    ];
                    
                    function logToConsole(message) {
                        const newLine = document.createElement('div');
                        newLine.textContent = message + '\n';
                        consoleOutput.appendChild(newLine);
                        newLine.scrollIntoView({ behavior: "smooth" });
                    }
                    
                    logToConsole("Console output...");
                                        
                    const PROCESSING_CODE_BEGIN = `
                    var feedbackString = \"\";
                    
                    function feedbackPrintln(s) {
                        return s + "\\n";
                    }

                    function feedbackPrint(s) {
                        return s;
                    }
                    
                    public static boolean drawn = false;
                            void setup() {
                                size(1, 1);
                                noLoop();
                            }
                            void draw() {
                                background(0);
                                fill(255);
                                stroke(255);`;

                    const PROCESSING_CODE_END = `
                    if (!drawn) {
                        const consoleOutput = document.getElementById(\'console\');
                        consoleOutput.textContent += feedbackString;
                        console.feedbackString = feedbackString;
                        console.log(console.feedbackString);
                        drawn = true;
                    }
                    }`;

                    /**
                     * Take code from the browser and put it into a form that can be sent to processing
                     * 
                     * @param {*} codeString All Java code (except for the main) that should be executed, as a string
                     * @param {*} mainString A string of the Java code that should go in main
                     * 
                     * @return The final code that should be executed by processing.js
                     */
                    function makeCodeJavaProcessing(codeString, mainString) {
                        var feedbackString = "";
                        let str = codeString.replace(/System.out.print/g, "feedbackString += feedbackPrint");
                        str += '\n' + PROCESSING_CODE_BEGIN;
                        str += '\n' + mainString.replace(/System.out.print/g, "feedbackString += feedbackPrint");
                        str += '\n' + PROCESSING_CODE_END;
                        // TODO: Hack for dealing with the fact that chars are cast to
                        // ints in this transpiler
                        str = str.replace(/'/g, "\"");
                        console.log(str);
                        return str;
                    }

                    /**
                     * Convert the whitespace in a particular string to HTML whitespace
                     * @param {string} s The input string
                     */
                    function getHTMLWhitespace(s) {
                        s = s.replace("\n", "<BR>");
                        s = s.replace("\t", "&nbsp&nbsp&nbsp&nbsp");
                        return s;
                    }

                    function removeTemplate(s) {
                        while (s.indexOf("<Integer>") > -1) {
                            s = s.replace("<Integer>", "");
                        }
                        while (s.indexOf("<String>") > -1) {
                            s = s.replace("<String>", "");
                        }
                        while (s.indexOf("<String, Integer>") > -1) {
                            s = s.replace("<String, Integer>", "");
                        }
                        while (s.indexOf("<Integer, Integer>") > -1) {
                            s = s.replace("<Integer, Integer>", "");
                        }
                        while (s.indexOf("<>") > -1) {
                            s = s.replace("<>", "");
                        }
                        return s;
                    }

                    const DB_NAME = 'CodeIDB';
                    const DB_VERSION = 1;
                    const STORE_NAME = 'Files';


                    {% if page.language != "pyodide" %}
                        logToConsole("Ready!");
                    {% endif %}
                    

                    function initDB() {
                        return new Promise((resolve, reject) => {
                            const request = indexedDB.open(DB_NAME, DB_VERSION);
                            request.onupgradeneeded = function(event) {
                                const db = event.target.result;
                                db.createObjectStore(STORE_NAME, { keyPath: 'path' });
                            };
                            request.onsuccess = function(event) {
                                resolve(event.target.result);
                            };
                            request.onerror = function(event) {
                                reject(event.target.error);
                            };
                        });
                    }

                    async function provideInitialFiles(files) {
                        const db = await initDB();
                        if (!db) {
                            console.error('Failed to initialize DB');
                            return;
                        }
                        const transaction = db.transaction(STORE_NAME, 'readwrite');
                        const store = transaction.objectStore(STORE_NAME);
                        for (let file of files) {
                            store.put({ path: rootBasePath + '/' + file.fileName, content: file.content, readOnly: file.readOnly, excludeFromExport: file.excludeFromExport, ismain: file.ismain });
                        }
                        transaction.oncomplete = function() {
                            console.log('Initial files provided successfully.');
                            getFilesFromDirectory(rootBasePath);
                        };
                        transaction.onerror = function(event) {
                            console.error('Error providing initial files:', event.target.error);
                        };
                    }

                    async function getFilesFromDirectory(directory) {
                        const db = await initDB();
                        if (!db) {
                            console.error('Failed to initialize DB');
                            return;
                        }
                        const transaction = db.transaction(STORE_NAME, 'readonly');
                        const store = transaction.objectStore(STORE_NAME);
                        const request = store.getAll();
                        request.onsuccess = function(event) {
                            const files = event.target.result.filter(file => file.path.startsWith(directory));
                            const treeData = [];
                            const directories = new Set();

                            files.forEach(file => {
                                const relativePath = file.path.replace(rootBasePath + '/', '');
                                const pathParts = relativePath.split('/').filter(Boolean);
                                let fullPath = '';
                                pathParts.forEach((part, index) => {
                                    fullPath += (index > 0 ? '/' : '') + part;
                                    if (index < pathParts.length - 1) {
                                        directories.add(fullPath);
                                    }
                                });

                                if (pathParts.length > 0) {
                                    const dirPath = pathParts.slice(0, -1).join('/') || '#';
                                    const fileName = pathParts[pathParts.length - 1];
                                    treeData.push({
                                        id: relativePath,
                                        parent: dirPath === '' ? '#' : dirPath,
                                        text: fileName,
                                        type: file.path.endsWith('/') ? 'folder' : 'file'
                                    });
                                }
                            });

                            directories.forEach(dir => {
                                const pathParts = dir.split('/').filter(Boolean);
                                const dirPath = pathParts.slice(0, -1).join('/') || '#';
                                const dirName = pathParts[pathParts.length - 1];
                                treeData.push({
                                    id: dir,
                                    parent: dirPath === '' ? '#' : dirPath,
                                    text: dirName,
                                    type: 'folder'
                                });
                            });

                            $('#filesystem').jstree(true).settings.core.data = treeData;
                            $('#filesystem').jstree(true).refresh();
                        };
                    }

                    // Append rootBasePath when a file is clicked
                    $('#filesystem').on('select_node.jstree', function (e, data) {
                        const node = data.node;
                        const fullPath = rootBasePath + '/' + node.id;
                        if (node.type === 'file') {
                            openFile(fullPath, node.text);
                        } 
                    });
                    
                    async function setTabAceProperties(path) {
                        const db = await initDB();
                        if (!db) {
                            console.error('Failed to initialize DB');
                            return;
                        }
                        const transaction = db.transaction(STORE_NAME, 'readonly');
                        const store = transaction.objectStore(STORE_NAME);
                        const request = store.get(path);
                                                
                        request.onsuccess = function(event) {
                            const file = event.target.result;
                            if (file) {
                                ace_editor.setFontSize(16);
                                // Default language settings
                                {% if page.language == "cpp" %}
                                ace_editor.session.setMode("ace/mode/c_cpp");
                                {% elsif page.language == "python" or page.language == "pyodide"%}
                                ace_editor.session.setMode("ace/mode/python");
                                {% elsif page.language == "sql" %}
                                ace_editor.session.setMode("ace/mode/sql");
                                {% elsif page.language == "java" %}
                                ace_editor.session.setMode("ace/mode/java");
                                {% elsif page.language == "javascript" or page.language == "graphics_view" or page.language == "graphics_shader" %}
                                ace_editor.session.setMode("ace/mode/javascript");
                                {% endif %}  
                                // Override based on file extension
                                if (path.match(/\.(cpp)$/)) {
                                    ace_editor.session.setMode("ace/mode/c_cpp");
                                }
                                else if (path.match(/\.(frag|vert)$/)) {
                                    ace_editor.session.setMode("ace/mode/glsl");
                                }
                                else if (path.match(/\.(py)$/)) {
                                    ace_editor.session.setMode("ace/mode/python");
                                }
                                else if (path.match(/\.(json|javascript)$/)) {
                                    ace_editor.session.setMode("ace/mode/javascript");
                                }

                                if(file.readOnly == true) {
                                    console.log("Read only file");
                                    ace_editor.setReadOnly(true);            
                                } else {
                                    console.log("Write enabled file");
                                    ace_editor.setReadOnly(false);            
                                }
                            }
                        }
                    }

                    async function openFile(path, name) {
                        const db = await initDB();
                        if (!db) {
                            console.error('Failed to initialize DB');
                            return;
                        }
                        const transaction = db.transaction(STORE_NAME, 'readonly');
                        const store = transaction.objectStore(STORE_NAME);
                        const request = store.get(path);
                        request.onsuccess = function(event) {
                            const file = event.target.result;
                            if (file) {
                                if (openFiles[path]) {
                                    setActiveTab(path);
                                } else {
                                    if (name.match(/\.(jpeg|jpg|gif|png)$/)) {
                                        displayImage(file.content);
                                        logToConsole(`Opened image file: ${path}`);
                                    } else if (name.match(/\.(mp3|wav)$/)) {
                                        displayAudio(file.content);
                                        logToConsole(`Opened audio file: ${path}`);
                                    } else {
                                        openFiles[path] = { content: file.content, modified: false, readOnly: file.readOnly };
                                        createTab(path);
                                        if(user != `${defaultuser}` && !file.readOnly) {
                                            saveBtn.disabled = false;
                                        } else {
                                            saveBtn.disabled = true;
                                        }
                                                                                
                                        logToConsole(`Opened file: ${path}`);
                                    }
                                }
                            }
                        };
                    }
                    
                    function openMultipleFiles(fileNames) {
                        fileNames.forEach(fileName => {
                            const fullPath = `${rootBasePath}/${fileName}`;
                            openFile(fullPath, fileName);
                        });
                    }                    

                    async function setActiveTab(path) {
                        document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
                        document.getElementById(path).classList.add('active');
                        ace_editor.setValue(openFiles[path].content);
                        saveBtn.disabled = openFiles[path].readOnly;
                        setTabAceProperties(path);
                    }

                    function createTab(path) {
                        const tab = document.createElement('div');
                        tab.className = 'tab active';
                        tab.id = path;
                        tab.innerHTML = `${path.substring(path.lastIndexOf('/') + 1)} <span class="close">&times;</span>`;
                        tabs.appendChild(tab);
                        tab.onclick = () => setActiveTab(path);
                        tab.querySelector('.close').onclick = (e) => {
                            e.stopPropagation();
                            closeTab(path);
                        };
                        setActiveTab(path);
                    }

                    async function closeTab(path) {
                        if(openFiles[path]) {
                            if (openFiles[path].modified) {
                                if (confirm('File has been modified. Save changes?')) {
                                    await saveFile(path);
                                }
                            }
                            delete openFiles[path];
                        }
                        if(document.getElementById(path)) {
                            document.getElementById(path).remove();
                        }
                        if (Object.keys(openFiles).length > 0) {
                            setActiveTab(Object.keys(openFiles)[0]);
                        } else {
                            ace_editor.setValue('');
                            ace_editor.setReadOnly(true);
                            saveBtn.disabled = true;
                        }
                    }

                    async function saveFile(path) {
                        const db = await initDB();
                        if (!db) {
                            console.error('Failed to initialize DB');
                            return;
                        }
                        const transaction = db.transaction(STORE_NAME, 'readwrite');
                        const store = transaction.objectStore(STORE_NAME);
                        const request = store.get(path);
                        request.onsuccess = function(event) {
                            if(openFiles[path].readOnly == false) {
                                const file = event.target.result;
                                file.content = openFiles[path].content;
                                store.put(file);
                                openFiles[path].modified = false;
                                logToConsole(`Saved file: ${path}`);
                                console.log('File saved successfully!');
                            } else {
                                console.log("Skipping save of read-only file.");
                            }
                        };
                    }
                    
                    wrapTextCheckbox.addEventListener('change', function() {
                        const consoleOutput = document.getElementById('console');
                        if (this.checked) {
                            consoleOutput.style.whiteSpace = 'pre-wrap'; 
                            consoleOutput.style.overflowX = 'hidden'; 
                        } else {
                            consoleOutput.style.whiteSpace = 'pre'; 
                            consoleOutput.style.overflowX = 'auto'; 
                        }
                    });  

                    // Set initial text wrap state based on the checkbox
                    if (wrapTextCheckbox.checked) {
                        consoleOutput.style.whiteSpace = 'pre-wrap';
                        consoleOutput.style.overflowX = 'hidden';
                    } else {
                        consoleOutput.style.whiteSpace = 'pre';
                        consoleOutput.style.overflowX = 'auto';
                    }                    
                    
                    clearButton.addEventListener('click', () => {
                        consoleOutput.innerHTML = '';
                    });                    

                    loginBtn.addEventListener('click', async () => {
                        const userId = prompt("Enter your user ID:");
                        if (userId && userId != `${defaultuser}`) {
                            localStorage.setItem('userId', userId);
                            user = userId;
                            rootBasePath = `/${user}/${projectName}`;
                            clearTabsAndCanvas();
                            updateUserStatus();
                            const isDirectoryEmpty = await checkIfDirectoryEmpty(rootBasePath);
                            if (isDirectoryEmpty) {
                                await provideInitialFiles(initialFiles);
                            } else {
                                getFilesFromDirectory(rootBasePath);
                            }
                            {% if page.openFilesOnLoad %}
                            // open initial files, if available
                            var filesToOpen = {{ page.openFilesOnLoad | jsonify }};
                            openMultipleFiles(filesToOpen);
                            {% endif %}

                        } else {
                            alert('Unable to log in with the given username');
                        }
                    });

                    logoutBtn.addEventListener('click', async () => {
                        localStorage.removeItem('userId');
                        user = `${defaultuser}`;
                        rootBasePath = `/${user}/${projectName}`;
                        clearTabsAndCanvas();
                        updateUserStatus();
                        getFilesFromDirectory(rootBasePath);
                    });

                    runBtn.addEventListener('click', () => {
                        saveActiveTabs();
                        
                        logToConsole("Running...");
                        runCode();
                    });
                    
                    function saveActiveTabs() {
                        logToConsole("Saving open tabs...");
                        
                        document.querySelectorAll('.tab').forEach(tab => saveFile(tab.id));
                    }
                    
                    function saveActiveTab() {
                        logToConsole("Saving active tab...");
                        
                        const activeTab = document.querySelector('.tab.active');
                        if (activeTab) {
                            saveFile(activeTab.id);
                        }                    
                    }

                    saveBtn.addEventListener('click', () => {
                        saveActiveTabs();
                    });

                    uploadBtn.addEventListener('click', () => {
                        const input = document.createElement('input');
                        input.type = 'file';
                        input.onchange = async function(event) {
                            const file = event.target.files[0];
                            const path = rootBasePath + '/' + file.name;
                            let content = '';
                            if (file.type.startsWith('image/') || file.type.startsWith('audio/')) {
                                const reader = new FileReader();
                                reader.onload = function(e) {
                                    content = e.target.result.split(',')[1];
                                    saveFileToDB(path, content, false, true);
                                };
                                reader.readAsDataURL(file);
                            } else {
                                content = await file.text();
                                saveFileToDB(path, content, false, true);
                            }
                        };
                        input.click();
                    });

                    async function saveFileToDB(path, content, readOnly, excludeFromExport) {
                        const db = await initDB();
                        if (!db) {
                            console.error('Failed to initialize DB');
                            return;
                        }
                        const transaction = db.transaction(STORE_NAME, 'readwrite');
                        const store = transaction.objectStore(STORE_NAME);
                        store.put({ path: path, content: content, readOnly: readOnly, excludeFromExport: excludeFromExport, ismain: false });
                        transaction.oncomplete = function() {
                            getFilesFromDirectory(rootBasePath);
                            logToConsole(`Uploaded file: ${path}`);
                        };
                    }

                    newBtn.addEventListener('click', async () => {
                        const fileName = prompt("Enter file name:");
                        if (fileName) {
                            const path = rootBasePath + '/' + fileName;
                            const db = await initDB();
                            if (!db) {
                                console.error('Failed to initialize DB');
                                return;
                            }
                            const transaction = db.transaction(STORE_NAME, 'readwrite');
                            const store = transaction.objectStore(STORE_NAME);
                            store.put({ path: path, content: '', readOnly: false, excludeFromExport: false, ismain: false });
                            transaction.oncomplete = function() {
                                getFilesFromDirectory(rootBasePath);
                                openFile(path, fileName);
                                logToConsole(`Created new file: ${fileName}`);
                            };
                        }
                    });

                    newDirBtn.addEventListener('click', async () => {
                        const dirName = prompt("Enter directory name:");
                        if (dirName) {
                            const path = rootBasePath + '/' + dirName;
                            const db = await initDB();
                            if (!db) {
                                console.error('Failed to initialize DB');
                                return;
                            }
                            const transaction = db.transaction(STORE_NAME, 'readwrite');
                            const store = transaction.objectStore(STORE_NAME);
                            store.put({ path: path + '/', content: '', readOnly: false, excludeFromExport: false, ismain: false });
                            transaction.oncomplete = function() {
                                getFilesFromDirectory(rootBasePath);
                                logToConsole(`Created new directory: ${dirName}`);
                            };
                        }
                    });

                    downloadBtn.addEventListener('click', async () => {
                        const zip = new JSZip();
                        const allFiles = await getAllFilesRecursively(rootBasePath);
                        const userId = localStorage.getItem('userId') || `${defaultuser}`;

                        allFiles.forEach(file => {
                            const relativePath = file.path.replace(rootBasePath + '/', '');
                            if (!(file.excludeFromExport)) {
                                if (isBase64(file.content)) {
                                    const decodedContent = base64ToUint8Array(file.content);
                                    zip.file(relativePath, decodedContent);
                                } else {
                                    zip.file(relativePath, file.content);
                                }
                            }
                        });

                        zip.generateAsync({ type: 'blob' }).then(function(content) {
                            const a = document.createElement('a');
                            a.href = URL.createObjectURL(content);
                            a.download = `${userId}-{{ page.canvasasmtid }}.zip`;
                            a.click();
                        });
                    });

                    resetBtn.addEventListener('click', async () => {
                        if (confirm('Are you sure you want to reset the file system?')) {
                            await clearDBPath(rootBasePath);
                            await provideInitialFiles(initialFiles);
                            clearTabsAndCanvas();
                            {% if page.openFilesOnLoad %}
                            // open initial files, if available
                            var filesToOpen = {{ page.openFilesOnLoad | jsonify }};
                            openMultipleFiles(filesToOpen);
                            {% endif %}
                        }
                    });

                    async function clearTabsAndCanvas() {
                        for(tab in tabs) {
                            closeTab(tab.id);
                        }
                        document.querySelectorAll('.tab').forEach(tab => tab.remove());
                        ace_editor.setValue('');
                        ace_editor.setReadOnly(true);
                        openFiles = {};
                        imageArea.innerHTML = "";
                        audioArea.innerHTML = "";
                    }
                    
                    /**
                     * Get the main files that match a particular filter function
                     * 
                     * @param {String} directory Directory to search in
                     * @param {function} filterFn Function to run on each file to determine whether to include it.  If not specified, returns true always
                     * 
                     */
                    async function getMainFileContentsRecursively(directory, filterFn) {
                        if (filterFn === undefined) {
                            filterFn = () => true;
                        }
                        const db = await initDB();
                        if (!db) {
                            console.error('Failed to initialize DB');
                            return;
                        }
                        const transaction = db.transaction(STORE_NAME, 'readonly');
                        const store = transaction.objectStore(STORE_NAME);
                        const request = store.getAll();

                        return new Promise((resolve, reject) => {
                            request.onsuccess = async function(event) {
                                let files = event.target.result.filter(file => file.path.startsWith(directory));
                                files = files.filter(file => filterFn(file));
                                let combinedContent = '';

                                for (const file of files) {
                                    if(file.ismain == true) {
                                        const fileContent = file.content; 
                                        combinedContent += fileContent + '\n';
                                    }
                                }

                                resolve(combinedContent.trim()); // Trim to remove the last unnecessary newline
                            };

                            request.onerror = function(event) {
                                reject(event.target.error);
                            };
                        });
                    }
                    
                    /**
                     * Get all but the main files that match a particular filter function
                     * 
                     * @param {String} directory Directory to search in
                     * @param {function} filterFn Function to run on each file to determine whether to include it.  If not specified, returns true always
                     * 
                     */
                    async function getAllFileContentsRecursively(directory, filterFn) {
                        if (filterFn === undefined) {
                            filterFn = () => true;
                        }
                        const db = await initDB();
                        if (!db) {
                            console.error('Failed to initialize DB');
                            return;
                        }
                        const transaction = db.transaction(STORE_NAME, 'readonly');
                        const store = transaction.objectStore(STORE_NAME);
                        const request = store.getAll();

                        return new Promise((resolve, reject) => {
                            request.onsuccess = async function(event) {
                                let files = event.target.result.filter(file => file.path.startsWith(directory));
                                files = files.filter(file => filterFn(file));
                                let combinedContent = '';

                                for (const file of files) {
                                    if(!file.ismain) {
                                        const fileContent = file.content; 
                                        combinedContent += fileContent + '\n';
                                    }                                   
                                }

                                resolve(combinedContent.trim()); // Trim to remove the last unnecessary newline
                            };

                            request.onerror = function(event) {
                                reject(event.target.error);
                            };
                        });
                    }

                    async function getAllFilesRecursively(directory) {
                        const db = await initDB();
                        if (!db) {
                            console.error('Failed to initialize DB');
                            return;
                        }
                        const transaction = db.transaction(STORE_NAME, 'readonly');
                        const store = transaction.objectStore(STORE_NAME);
                        const request = store.getAll();
                        return new Promise((resolve, reject) => {
                            request.onsuccess = function(event) {
                                const files = event.target.result.filter(file => file.path.startsWith(directory));
                                resolve(files);
                            };
                            request.onerror = function(event) {
                                reject(event.target.error);
                            };
                        });
                    }

                    async function encryptFiles(files, halfcredit, points) {
                        const aesKey = await window.crypto.subtle.generateKey(
                            {
                                name: 'AES-CBC',
                                length: 256,
                            },
                            true,
                            ['encrypt', 'decrypt']
                        );

                        const iv = window.crypto.getRandomValues(new Uint8Array(16));
                        const encoder = new TextEncoder();

                        const encryptedFiles = [];
                        for (const file of files) {
                            const encodedContent = encoder.encode(file.content);
                            const encryptedContent = await window.crypto.subtle.encrypt(
                                {
                                    name: 'AES-CBC',
                                    iv: iv,
                                },
                                aesKey,
                                encodedContent
                            );
                            encryptedFiles.push({
                                name: file.path.substring(rootBasePath.length + 1),
                                content: arrayBufferToBase64(encryptedContent)
                            });
                        }

                        const exportedAesKey = await window.crypto.subtle.exportKey('raw', aesKey);
                        const rsaEncrypt = new JSEncrypt();
                        rsaEncrypt.setPublicKey(publicKey);
                        const encryptedAesKey = rsaEncrypt.encrypt(arrayBufferToBase64(exportedAesKey));

                        // Encrypt the userId
                        const userId = localStorage.getItem('userId') || `${defaultuser}`;
                        const encodedUserId = encoder.encode(userId);
                        const encryptedUserId = await window.crypto.subtle.encrypt(
                            {
                                name: 'AES-CBC',
                                iv: iv,
                            },
                            aesKey,
                            encodedUserId
                        );

                        if (encryptedAesKey) {
                            const encryptedPackage = {
                                iv: arrayBufferToBase64(iv.buffer),
                                aesKey: encryptedAesKey,
                                files: encryptedFiles,
                                user: arrayBufferToBase64(encryptedUserId), 
                                courseId: courseid,
                                asmtId: asmtid,
                                halfcredit: halfcredit,
                                points: points
                            };

                            return window.btoa(JSON.stringify(encryptedPackage));
                        } else {
                            throw new Error("Encryption failed.");
                        }
                    }

                    function isBase64(str) {
                        try {
                            return btoa(atob(str)) === str;
                        } catch (err) {
                            return false;
                        }
                    }

                    // Utility function to convert ArrayBuffer to Base64 string
                    function arrayBufferToBase64(buffer) {
                        const binary = String.fromCharCode.apply(null, new Uint8Array(buffer));
                        return window.btoa(binary);
                    }

                    function arrayBufferToBase64(buffer) {
                        let binary = '';
                        const bytes = new Uint8Array(buffer);
                        const len = bytes.byteLength;
                        for (let i = 0; i < len; i++) {
                            binary += String.fromCharCode(bytes[i]);
                        }
                        return window.btoa(binary);
                    }

                    function base64ToArrayBuffer(base64) {
                        const binaryString = window.atob(base64);
                        const len = binaryString.length;
                        const bytes = new Uint8Array(len);
                        for (let i = 0; i < len; i++) {
                            bytes[i] = binaryString.charCodeAt(i);
                        }
                        return bytes.buffer;
                    }

                    /**
                     * Create an image tag in the image area with the base64 binary code of the image, and
                     * scale the image to fit into the area
                     * 
                     * @param {String} content Base64 binary of the image
                     * @param {String} hasHeader If it has a header, no need to prepend anything.  Default false
                     */
                    function displayImage(content, hasHeader) {
                        if (!hasHeader || hasHeader === undefined) {
                            content = 'data:image/jpeg;base64,' + content;
                        }
                        let html = "<img src = \"" + content + "\" width=\"100%;\">";
                        imageArea.innerHTML = html;
                    }

                    /**
                     * Create an image tag in the image area with the base64 binary code of the image, and
                     * scale the image to fit into the area
                     * 
                     * @param {String} content Base64 binary of the image
                     * @param {String} hasHeader If it has a header, no need to prepend anything.  Default false
                     */
                    function displayAudio(content, hasHeader) {
                        if (!hasHeader || hasHeader === undefined) {
                            content = 'data:audio/mp3;base64,' + content;
                        }
                        let html = "<audio controls><source src=\"" + content + "\" type=\"audio/wav\">Your browser does not support the audio element</audio>";
                        audioArea.innerHTML = html;
                    }
                    
                    function waitForElement(selector, timeout = 3000) {
                        return new Promise((resolve, reject) => {
                            const interval = 100; // Check every 100ms
                            const endTime = Date.now() + timeout;

                            (function check() {
                                if ($(selector).length > 0) {
                                    resolve($(selector));
                                } else if (Date.now() > endTime) {
                                    reject(new Error(`Element ${selector} not found within timeout`));
                                } else {
                                    setTimeout(check, interval);
                                }
                            })();
                        });
                    }

                    window.addEventListener('load', async () => {
                        await waitForElement('#filesystem');
                        await waitForElement('#editor-container');
                        
                        ace_editor = ace.edit("editor-container");
                        
                        ace_editor.session.on('change', function(delta) {
                            // delta.start, delta.end, delta.lines, delta.action
                            //console.log("File contents changed...");
                            const activeTab = document.querySelector('.tab.active');
                            if (activeTab) {
                                openFiles[activeTab.id].content = ace_editor.getValue();
                                openFiles[activeTab.id].modified = true;
                            }
                        });
                    
                        $('#filesystem').jstree({
                            'core': {
                                'data': [],
                                'themes': {
                                    'variant': 'large'
                                },
                                'check_callback': true
                            },
                            'types': {
                                'file': {
                                    'icon': 'jstree-file'
                                },
                                'folder': {
                                    'icon': 'jstree-folder'
                                }
                            },
                            'plugins': ['types']
                        }).on('select_node.jstree', function (e, data) {
                            const node = data.node;
                            if (node.type === 'file') {
                                openFile(node.id, node.text);
                            } 
                        });

                        updateUserStatus();
                        const db = await initDB();
                        if (!db) {
                            console.error('Failed to initialize DB');
                            return;
                        }
                        
                        const isDirectoryEmpty = await checkIfDirectoryEmpty(rootBasePath);
                        if (isDirectoryEmpty) {
                            await provideInitialFiles(initialFiles);
                        } else {
                            getFilesFromDirectory(rootBasePath);
                        }
                        
                        {% if page.openFilesOnLoad %}
                        if (!(user === defaultuser)) {
                            // open initial files, if available
                            var filesToOpen = {{ page.openFilesOnLoad | jsonify }};
                            openMultipleFiles(filesToOpen);
                        }
                        {% endif %}
                    });

                    async function clearDBPath(path) {
                        const db = await initDB();
                        if (!db) {
                            console.error('Failed to initialize DB');
                            return;
                        }
                        const transaction = db.transaction(STORE_NAME, 'readwrite');
                        const store = transaction.objectStore(STORE_NAME);
                        const request = store.getAll();

                        return new Promise((resolve, reject) => {
                            request.onsuccess = function(event) {
                                const files = event.target.result;
                                const filesToDelete = files.filter(file => file.path.startsWith(path));
                                filesToDelete.forEach(file => store.delete(file.path));
                                
                                transaction.oncomplete = function() {
                                    resolve();
                                };
                                transaction.onerror = function(event) {
                                    reject(event.target.error);
                                };
                            };
                            request.onerror = function(event) {
                                reject(event.target.error);
                            };
                        });
                    }

                    async function clearDB() {
                        const db = await initDB();
                        if (!db) {
                            console.error('Failed to initialize DB');
                            return;
                        }
                        const transaction = db.transaction(STORE_NAME, 'readwrite');
                        const store = transaction.objectStore(STORE_NAME);
                        store.clear();
                        return new Promise((resolve, reject) => {
                            transaction.oncomplete = function() {
                                resolve();
                            };
                            transaction.onerror = function(event) {
                                reject(event.target.error);
                            };
                        });
                    }

                    function updateUserStatus() {
                        const userId = localStorage.getItem('userId');
                        if (userId) {
                            userStatus.textContent = `Logged in as ${userId}`;
                            loginBtn.style.display = 'none';
                            logoutBtn.style.display = 'block';
                            runBtn.disabled = false;
                            uploadBtn.disabled = false;
                            newBtn.disabled = false;
                            newDirBtn.disabled = false;
                            downloadBtn.disabled = false;
                            resetBtn.disabled = false;
                        } else {
                            userStatus.textContent = '';
                            loginBtn.style.display = 'block';
                            logoutBtn.style.display = 'none';
                            runBtn.disabled = true;
                            saveBtn.disabled = true;
                            uploadBtn.disabled = true;
                            newBtn.disabled = true;
                            newDirBtn.disabled = true;
                            downloadBtn.disabled = true;
                            resetBtn.disabled = true;
                        }
                    }

                    async function checkIfDirectoryEmpty(directory) {
                        const db = await initDB();
                        if (!db) {
                            console.error('Failed to initialize DB');
                            return;
                        }
                        const transaction = db.transaction(STORE_NAME, 'readonly');
                        const store = transaction.objectStore(STORE_NAME);
                        const request = store.getAll();
                        return new Promise((resolve, reject) => {
                            request.onsuccess = function(event) {
                                const files = event.target.result.filter(file => file.path.startsWith(directory));
                                resolve(files.length === 0);
                            };
                            request.onerror = function(event) {
                                reject(event.target.error);
                            };
                        });
                    }
                    
                    async function getCodeText(filterFn) {
                        let codeText = await getAllFileContentsRecursively(rootBasePath, filterFn);
                        
                        return codeText;
                    }
                    
                    async function getMainCodeText(filterFn) {
                        let codeText = await getMainFileContentsRecursively(rootBasePath, filterFn);
                        
                        return codeText;
                    }

                    {% if page.processor.submitformlink and page.processor.submitformlink != false %}
                    logToConsole("{{ layout.submitformlinkdirections }}");
                    {% endif %}

                    {% if page.language == "cpp" %}
                    const compileButton = document.createElement('button');
                    compileButton.type = 'button';
                    compileButton.id = 'compilebutton';
                    compileButton.onclick = saveAndCompile;
                    compileButton.innerText = 'Save Open Files and Compile';
                    document.querySelector('.actions').appendChild(compileButton);
                    {% endif %}

                    {% if page.language == "cpp" %}
                    let workerPath = "{{site.baseurl}}/assets/js/cpp/scripts/";
                    class ProcessUI {
                        constructor(name) {
                            this.text = "";
                            this.name = name;
                            this.state = '';
                            this.wasReady = false;
                            this.timesRun = 0;

                            this.process = new ProcessManager(name, name, workerPath)
                            this.process.setStatus = this.setStatus.bind(this);
                            this.process.print = this.print.bind(this);
                            this.process.printErr = this.printErr.bind(this);
                        }

                        resetText() {
                            this.text = "";
                        }

                        reboot() {
                            this.process.terminate();
                            this.process.start();
                        }

                        setStatus(state, status, doPrint) {
                            if (doPrint === undefined) {
                                doPrint = true;
                            }
                            if (doPrint) {
                                logToConsole(state + ' ' + status);
                            }
                            this.state = state;
                        };

                        print({ text }) {
                            this.text += text + "\n";
                            logToConsole(this.text);
                        };

                        printErr({ text }) {
                            this.text += text + "\n";
                            logToConsole(this.text);
                        };
                    }   

                    let clang = new ProcessUI('clang');
                    let runtime = new ProcessUI('runtime');
                    let clangOutput = null;

                    clang.process.print({ text: 'Preparing clang...\n\n' });
                    clang.process.workerCompileDone = args => {
                        clangOutput = args.result;
                        clang.process.setStatus('ready', 'Ready', false);
                        if (args.result) {
                            let s = "Compiled successfully: wasm size: " + args.result.length + ' bytes\n';
                            logToConsole(s);
                        }
                    };    

                    runtime.process.print({ text: 'Preparing runtime...\n\n' });
                    runtime.process.workerRunDone = async function(args) {
                        runtime.timesRun++;
                        if (runtime.timesRun < 3) {
                            // For some reason it needs to be run more than once
                            // for the text to fully update
                            runtime.resetText();
                            runtime.process.worker.postMessage({
                                function: 'run',
                                wasmBinary: clangOutput,
                            });
                        }
                        else {
                            runtime.process.setStatus('ready', 'Ready', false);
                            logToConsole(runtime.text);
                            await checkAnswer();
                        }

                    };
                    runtime.process.workerDebugReplaceBinary = args => {
                        console.log('new size:  ' + args.newBinary.length + '\n');
                        clangOutput = args.newBinary;
                    };
                    runtime.process.workerSendRun = function () {
                        runtime.process.setStatus('busy', 'Running');
                        runtime.process.postMessage({
                            function: 'run',
                            wasmBinary: clangOutput,
                        });
                    };

                    clang.process.start();
                    runtime.process.start(); 

                    let compiledCode = "";
                    
                    async function saveAndCompile() {
                        saveActiveTabs();
                        compile();
                    }

                    async function compile() {
                        logToConsole("Compiling...");
                        if (clang.state !== 'ready') {
                            alert("Compiler not finished loading yet");
                            return;
                        }
                        clangOutput = null;
                        clang.process.setStatus('busy', 'Running');
                        let codeText = await getCodeText();
                        let mainText = await getMainCodeText();
                        compiledCode = codeText + '\n\n' + mainText;
                        console.log(compiledCode);
                        clang.process.worker.postMessage({
                            function: 'compile',
                            code: compiledCode,
                        });
                    }
                    {% endif %}

                    {% if page.language == "sql" %}
                    async function doSql(codeString, mainString) {
                        feedbackString = "";
                        let code = mainString + '\n';
                        code += codeString + '\n';
                        console.log(code);
                        
                        config = {
                          locateFile: filename => "{{site.baseurl}}/assets/js/sql.js/sql.js"
                        }
                        
                        await initSqlJs(config).then(function(SQL){
                          const db = new SQL.Database();

                          stmts = code.split(';');
                          
                          for(var i = 0; i < stmts.length; i++) {
                            lines = stmts[i].split('\n');
                            
                            stmt = '';
                            for(var j = 0; j < lines.length; j++) {
                                if(!(lines[j].trim().startsWith("--")) && lines[j].trim().length >= 1) {
                                    stmt += lines[j] + ' ';
                                }
                            }
                            
                            stmt += ';';
                            
                            if(!(stmt.trim().startsWith("--")) && stmt.trim().length >= 1) {
                                console.log("Executing: " + stmt);
                                const res = db.exec(stmt);
                                const resStr = JSON.stringify(res);
                                feedbackString += resStr + '\n';
                            }
                          }
                          
                          logToConsole(feedbackString);
                        });
                        
                        return feedbackString;
                    }        
                    {% endif %}

                    {% if page.language == "pyodide" %}
                        // Load the required packages
                        let packages = [];
                        {% if page.info.packages %}
                        if ("{{page.info.packages}}".length > 0) {
                            packages = "{{page.info.packages}}".split(",");
                        }
                        {% endif %}
                        let pyodide = null;
                        let pyodideLoaded = false;

                        async function setupPyodide() {
                            pyodide = await loadPyodide();
                            logToConsole("Importing packages {{page.info.packages}}...");
                            for (let i = 0; i < packages.length; i++) {
                                await pyodide.loadPackage(packages[i]);
                            }
                            logToConsole("Finished loading packages.  You can run your code now.");
                            pyodideLoaded = true;
                        }

                        let pyodidePromise = new Promise((resolve) => {
                            setupPyodide().then(()=>{
                                resolve();
                            });
                        });

                        
                    {% endif %} // End of pyodide-specific code


                    {% if page.language == "graphics_view" or page.language == "graphics_shader" %}
                        document.getElementById("graphicsArea").style.display = "block";
                        let shaderPath = "{{site.baseurl}}/assets/js/ggslac/shaders/";
                        let meshesPath = "{{site.baseurl}}/assets/js/ggslac/meshes/";
                        let glcanvas = document.getElementById("GLCanvas1");
                        glcanvas.addEventListener("contextmenu", function(e){ e.stopPropagation(); e.preventDefault(); return false; }); //Need this to disable the menu that pops up on right clicking
                        let scene = new SceneCanvas(glcanvas, shaderPath, meshesPath, true, true, true);
                        scene.gui.close();
                        
                        /**
                         * Helper method for updateScene
                         * 
                         * @param {String} content The JSON code describing a scene
                         */
                        function updateSceneFromContent(content) {
                            scene.setupScene(JSON.parse(content), glcanvas.clientWidth, glcanvas.clientHeight);
                            scene.drawEdges = false;
                            scene.updateMeshDrawings();
                            scene.repaint();
                        }

                        /**
                         * Pull out the text from the file scene.json and update the
                         * scene in ggslac
                         * 
                         * @param {event} evt Button click event (if applicable)
                         * @param {boolean} firstTime If true, use scene.json in initialFiles.
                         * Otherwise, query the database and find the most recent version
                         */
                        async function updateScene(evt, firstTime) {
                            if (firstTime === undefined) {
                                firstTime = false;
                            }
                            let files = initialFiles;
                            if (!firstTime) {
                                files = await getAllFilesRecursively(rootBasePath);
                            }
                            try {
                                let foundScene = false;
                                for (let i = 0; i < files.length; i++) {
                                    let file = files[i];
                                    let path = file.fileName;
                                    let name = file.fileName;
                                    if (!firstTime) {
                                        path = file.path;
                                        name = path.split(rootBasePath)[1];
                                    }
                                    if (name.match(/(scene.json)$/)) {
                                        if (!firstTime) {
                                            await saveFile(path);
                                        }
                                        updateSceneFromContent(file.content);
                                        foundScene = true;
                                    }
                                }
                                if (!foundScene) {
                                    alert("No scene.json file found!");
                                }
                            }
                            catch(err) {
                                logToConsole("Error Parsing Scene: " + err.message);
                            }

                        }
                        updateScene(null, true);
                        document.getElementById("updateScene").onclick = updateScene;



                        let offscreenCanvas = document.createElement("canvas");
                        offscreenCanvas.width = glcanvas.width;
                        offscreenCanvas.height = glcanvas.height;
                        offscreenCanvas.ctx = offscreenCanvas.getContext("2d");

                        /**
                         * Decode a PNG image using an offscreen canvas
                         * @param pngSrc A base64 representation of the image in PNG format
                         * @return A promise for the decoded image
                         */
                        function decodeImage(pngSrc) {
                            return new Promise((resolve, reject) => {
                                let image = new Image();
                                image.src = pngSrc;
                                image.onload = function() {
                                    offscreenCanvas.ctx.drawImage(image, 0, 0);
                                    resolve(offscreenCanvas.ctx.getImageData(0, 0, glcanvas.width, glcanvas.height));
                                }
                            });

                        }

                        const DEFAULT_TOL = 2*255*500;
                        /**
                         * Decode two PNG images and compare them pixel by pixel
                         * @param pngSrc1 A base64 representation of the first image in PNG format
                         * @param pngSrc2 A base64 representation of the second image in PNG format
                         * @return A promise for the equality check
                         */
                        function pngImagesEqualTol(pngSrc1, pngSrc2, tol, name) {
                            if (tol === undefined) {
                                tol = DEFAULT_TOL;
                            }
                            if (name == undefined) {
                                name = "";
                            }
                            return new Promise((resolve, reject) => {
                                decodeImage(pngSrc1).then(function(I1) {
                                    decodeImage(pngSrc2).then(function(I2) {
                                        let diff = 0;
                                        for (let i = 0; i < I1.data.length; i++) {
                                            diff += Math.abs(I1.data[i] - I2.data[i]);
                                        }
                                        console.log(name + ": " + diff);
                                        resolve(diff < tol);
                                    });
                                });
                            });
                        }
                    {% endif %} // End of graphics-specific code


                    {% if page.language == "graphics_shader" %}
                        async function finalizeShader(vertexSrc, fragmentSrc) {
                            // This is a hack since the default shader is blinnPhong
                            if ("shaderReady" in scene.shaders.blinnPhong) {
                                await scene.shaders.blinnPhong;
                            }
                            let gl = scene.gl;
                            let shader = getShaderProgram(gl, "studentShader", vertexSrc, fragmentSrc);
                            shader.shaderReady = true;
                            shader.description = 'Student shader';
                            shader.vPosAttrib = gl.getAttribLocation(shader, "vPos");
                            gl.enableVertexAttribArray(shader.vPosAttrib);
                            shader.vNormalAttrib = gl.getAttribLocation(shader, "vNormal");
                            gl.enableVertexAttribArray(shader.vNormalAttrib);
                            shader.vColorAttrib = gl.getAttribLocation(shader, "vColor");
                            gl.enableVertexAttribArray(shader.vColorAttrib);
                            shader.pMatrixUniform = gl.getUniformLocation(shader, "uPMatrix");
                            shader.mvMatrixUniform = gl.getUniformLocation(shader, "uMVMatrix");
                            shader.tMatrixUniform = gl.getUniformLocation(shader, "tMatrix");
                            shader.nMatrixUniform = gl.getUniformLocation(shader, "uNMatrix");
                            shader.ambientColorUniform = gl.getUniformLocation(shader, "uAmbientColor");
                            shader.uKaUniform = gl.getUniformLocation(shader, "uKa");
                            shader.uKdUniform = gl.getUniformLocation(shader, "uKd");
                            shader.uKsUniform = gl.getUniformLocation(shader, "uKs");
                            shader.uShininessUniform = gl.getUniformLocation(shader, "uShininess");
                            shader.uEyeUniform = gl.getUniformLocation(shader, "uEye");
                            shader.u_lights = [];
                            shader.u_numLights = gl.getUniformLocation(shader, "numLights");
                            for (let i = 0; i < MAX_LIGHTS; i++) {
                                let light = {
                                    pos: gl.getUniformLocation(shader, "lights["+i+"].pos"),
                                    color: gl.getUniformLocation(shader, "lights["+i+"].color"),
                                    atten: gl.getUniformLocation(shader, "lights["+i+"].atten")
                                };
                                shader.u_lights.push(light);
                            }
                            scene.shaderToUse = shader;
                            requestAnimationFrame(scene.repaint.bind(scene));
                        }


                        /**
                         * Pull out the text from the first vertex shader and the first
                         * fragment shader that are found
                         * 
                         * @param {event} evt Button click event (if applicable)
                         * @param {boolean} firstTime If true, use shaders in initialFiles.
                         * Otherwise, query the database and find the most recent version
                         */
                         async function updateShaders(evt, firstTime) {
                            if (firstTime === undefined) {
                                firstTime = false;
                            }
                            let files = initialFiles;
                            if (!firstTime) {
                                files = await getAllFilesRecursively(rootBasePath);
                            }
                            try {
                                let foundVert = false;
                                let foundFrag = false;
                                let vertexSrc = "";
                                let fragmentSrc = "";
                                for (let i = 0; i < files.length; i++) {
                                    let file = files[i];
                                    let path = file.fileName;
                                    let name = file.fileName;
                                    if (!firstTime) {
                                        path = file.path;
                                        name = path.split(rootBasePath)[1];
                                    }
                                    if (name.match(/(.vert)$/)) {
                                        if (!firstTime) {
                                            await saveFile(path);
                                        }
                                        vertexSrc = file.content;
                                        foundVert = true;
                                    }
                                    else if (name.match(/(.frag)$/)) {
                                        if (!firstTime) {
                                            await saveFile(path);
                                        }
                                        fragmentSrc = file.content;
                                        foundFrag = true;
                                    }
                                }
                                if (!foundVert) {
                                    alert("No vertex shader file found!");
                                }
                                if (!foundFrag) {
                                    alert("No fragment shader file found!");
                                }
                                if (foundVert && foundFrag) {
                                    await finalizeShader(vertexSrc, fragmentSrc);
                                }
                                scene.repaint();
                            }
                            catch(err) {
                                logToConsole("Error Compiling Shader: check Javscript console");
                            }

                        }
                        updateShaders(null, true);
                        document.getElementById("updateShaders").onclick = updateShaders;

                    {% endif %} // End of graphics shader-specific code


                    async function runCode() {
                        try {
                            let filterFn = undefined;
                            {% if page.language == "pyodide" %}
                            filterFn = (file) => file.path.slice(-3) === ".py"
                            {% endif %}

                            let editorText = await getCodeText(filterFn);
                            let mainText = await getMainCodeText(filterFn);

                            
                            {% if page.language == "cpp" %}
                            runtime.timesRun = 0;
                            logToConsole("Running...");

                            let codeText = editorText + '\n\n' + mainText;
                            
                            if (!(codeText === compiledCode)) {
                                logToConsole("Warning: It looks like you edited code since you last compiled\nBe sure to compile again before running!");
                            }
                            runtime.process.setStatus('busy', 'Running');
                            if (clangOutput === null) {
                                alert("Need to compile code first!");
                            }
                            else {
                                runtime.resetText();
                                runtime.process.worker.postMessage({
                                    function: 'run',
                                    wasmBinary: clangOutput,
                                });
                            }              
                            {% elsif page.language == "python" %}                            
                            let student_code = editorText + '\n\n' + mainText;
                            console.log(student_code);
                            feedbackString = run_python_code(student_code);
                            logToConsole(feedbackString);    



                            

                            {% elsif page.language == "pyodide" %}
                            ////////////////////////  PYODIDE ////////////////////////////////
                            if (!pyodideLoaded) {
                                await pyodidePromise;
                            }
                            let student_code = editorText + "\n\n" + document.getElementById("pyodideBoilerplate").innerHTML + "\n\n" + mainText;
                            console.log(student_code);
                            pyodide.runPython(student_code);
                            // Process images if necessary
                            imgStr = pyodide.globals.get("img_str");
                            if (imgStr.length > 0) {
                                displayImage(imgStr, true);
                            }
                            // Process audio if necessary
                            audioStr = "";
                            let samples = pyodide.globals.get("audio_sav_arr");
                            if (samples.length > 0) {
                                let sr = pyodide.globals.get("audio_sav_sr");
                                audioStr = await writeWavAudioSource(audioArea, samples, sr);
                            }
                            //////////////////////////////////////////////////////////////////



                            
                            {% elsif page.language == "graphics_view" %}
                            /////////////////////  GRAPHICS VIEW /////////////////////////////
                            console.log("editorText\n", editorText);
                            await updateScene();
                            eval(editorText);
                            scene.repaint();
                            canvasStr = glcanvas.toDataURL();
                            //////////////////////////////////////////////////////////////////

                            {% elsif page.language == "graphics_shader"%}
                            ////////////////////  GRAPHICS SHADER ////////////////////////////
                            console.log("editorText\n", editorText);
                            await updateShaders();
                            await updateScene();
                            scene.repaint();
                            canvasStr = glcanvas.toDataURL();
                            //////////////////////////////////////////////////////////////////



                            {% elsif page.language == "sql" %}
                            feedbackString = await doSql(editorText, mainText); 
                            logToConsole(feedbackString);    


                            {% elsif page.language == "java" %}                             
                            let code = makeCodeJavaProcessing(editorText, mainText);
                            console.log(code);
                            console.feedbackString = null;
                            instance = new Processing(canvas, code);
                            while(console.feedbackString == null); // await processing
                            feedbackString = console.feedbackString; // passing globals from anonymous scope via console in processing boilerplate code
                            logToConsole(console.feedbackString);



                            {% elsif page.language == "javascript" %}
                            function feedbackPrintlnJSConsole(s) {
                                logToConsole(s);
                                return s + "\n";
                            }
                            let code = editorText + "\n\n" + mainText;
                            code = code.replace(/console.log/g, "feedbackString += feedbackPrintlnJSConsole");
                            eval(code);
                            {% endif %}
                            
                            await checkAnswer();
                        } catch(err) {
                            logToConsole("{{ page.processor.incorrectfeedback | strip }}");
                            console.log("Exception in runCode");
                            logToConsole("Error: " + err.message);
                        }              
                    }

                    async function checkAnswer() {
                        console.log("Got feedback string: " + feedbackString);
                        
                        const points = {% if page.info.points %}{{page.info.points}}{% else %}0{% endif %};
                        
                        numAttempts++;
                        {{ page.processor.feedbackprocess | strip }}
                        if ({{ page.processor.correctcheck | strip}}) {
                            correctlyAnswered = true;
                            logToConsole("{{ page.processor.correctfeedback | strip}}");
                            postCode(false, false, points);
                        }
                        {% if page.processor.incorrectchecks %}
                        {% for check in page.processor.incorrectchecks %}
                        else if ({{ check.incorrectcheck | strip}}) {
                            logToConsole("{{ check.feedback | strip }}");
                        }
                        {% endfor %}
                        {% endif %}
                        else {
                            logToConsole("{{ page.processor.incorrectfeedback | strip }}");
                        }
                        {% if page.canvashalftries %}
                        if (!correctlyAnswered && numAttempts == {{ page.canvashalftries }}) {
                            postCode(true, false, points);
                        }
                        {% endif %}
                    }
                    
                    async function postCode(halfcredit, downloadblob, points) {
                        // download encrypted submission version
                        const allFiles = await getAllFilesRecursively(rootBasePath);
                        const filteredFiles = allFiles.filter(file => !(file.excludeFromExport));
                        const encryptedContent = await encryptFiles(filteredFiles, halfcredit, points);

                        let url = `{% if layout.formlink %}{{ layout.formlink }}{% else %}{{ site.formlink }}{% endif %}` + encryptedContent;
                        console.log("len(url)", url.length);
                        window.location.href = url; // window.open(url);                     
                        
                        // download encrypted submission version, if desired
                        if(downloadblob) {
                            const userId = localStorage.getItem('userId') || `${defaultuser}`;
                            const blob = new Blob([encryptedContent], { type: 'text/plain' });
                            const a = document.createElement('a');
                            a.href = URL.createObjectURL(blob);
                            a.download = `${userId}-{{ page.canvasasmtid }}.txt`;
                            a.click();
                        }
                    }

                    function urlencodeFormData(fd){
                        var s = '';
                        function encode(s){ return encodeURIComponent(s).replace(/%20/g,'+'); }
                        for(var pair of fd.entries()){
                            if(typeof pair[1]=='string'){
                                s += (s?'&':'') + encode(pair[0])+'='+encode(pair[1]);
                            }
                        }
                        return s;
                    }
                });
            </script>

    {{ content }} 
  </div>
</div>
